# 计算机网络

## **1.计算机网络的TCP/IP协议有几层**

TCP/IP网络一共分为四层，从最上层到最下层分别为**应用层**、**传输层**、**网络层**、网络接口层，其中应用层是最上层，在操作系统的用户态下就可以完成，越往下就越接近底层，都需要进入内核态来完成，应用层主要服务于应用程序，包括HTTP、FTP协议，而他并不关心数据是如何传输的，该层的协议可以直接协助用户的应用程序进行工作，传输层为应用层的数据传输提供了协议支持，为数据的传输制定了规范，确保了传输的可靠性或者及时性，TCP和UDP协议就是属于这一层的，而且还提供了流量控制和窗口控制等功能。网络层是负责实际传输的一层，由网络层来面对和解决网络环境中错综复杂的节点和路径，把数据发送到目的地，IP协议就是这一层的协议，例如IPV4就有32位地址，可以通过与子网掩码的运算找到网络号和主机号，最下面一层就是网络接口层，在前面加上mac头部发送到网上

拓展：为什么需要加上Mac头部呢？因为IP地址表示网络包的地址，而在以太网中这个思路是不行的，其中以太网就是由电脑上的以太接口、WI-Fi接口、路由器上的千兆和万兆的网络接口组成的。所以加上MAC头部，就可以知道了接收方和发送方的MAC地址等信息，总的来说网络接口层主要提供【链路级别】的传输服务

osi七层模型，其中应用层又可以细分为应用层、表示层、会话层级；网络接口层级又可以分为数据链路层和物理层

## **2.键入网址到网页显示出来，这期间都发生了些什么**

**第一步：解析URL，生成HTTP请求**

打给比方，你的浏览器的地址栏的地址是http://baidu.com,这个时候URL就会解析出来这个请求是http协议的，//后面代表了他要访问的文件，其中baidu.com是服务器的名称，这里后面没有附带路径，这个时候就会默认访问这个服务器下面的index.html,

**第二步：利用DNS解析真实地址**

通过解析URL我们已经得到了生成的HTTP请求，我们需要发送到对应的web端服务器，但是www.baidu.com只是为了方便人们记忆的一个名字，背后真是的地址是数字ip地址，这就类似于电话通讯录里的名字和他的电话号码，通讯录里面的好友张三只是一个代号，打给张三实际上是打给张三背后的电话号码18812345678，而这个DNS域名服务器系统就是一个记录了域名和ip地址映射的系统或者数据库

**第三步：利用协议栈进行传输工作**

生成http请求并获得真实ip地址后，浏览器会通过socket库来委托协议栈进行工作，协议栈属于操作系统级别，分为上下两层，上层是传输层，常见有TCP和UDP两种协议，下层是网络层，常见的有ip协议，首先HTTP所携带的数据包建立TCP协议，通过TCP协议的三次握手建立稳定的数据传输链接，给数据包加上TCP头部，紧接着再通过IP协议给数据包加上IP头部封装成网络包，最后再加上Mac头部，可以让网络包找到以太网中设备的位置

**第四步：通过网卡进行电信号转换**

此时的网络包还只是存储在内存中的二进制信号，需要利用网卡驱动程序控制网卡来对二进制信号转换成电信号，使其可以通过网线来传输，在这之前网卡驱动程序会提前控制网卡把数据包复制到网卡的缓存中，加上报头、起始帧分节符、帧检验序列

**第五步：通过交换机和路由器接力到达服务器**

到达服务器后，服务器根据网络包返回客户端想要的数据进行返回，客户端拿到返回的数据后，服务器进行渲染，网页就加载出来了，最后TCP进行四次挥手就断开连接了

-----------------------------------HTTP篇-----------------------------------

## **1.HTTP是什么？**

HTTP全称“超文本传输协议”，是一个在计算机体系中，**两点**之间**传输**文字、图片视频等“**超文本**”的一种规范和约定

## **2.HTTP有哪些常见的状态码呢？**

HTTP的状态码分为五类，100类代表中间状态，很少遇到，200类代表成功的状态，常见的有200,204，其中204不会返回body体，300类代表重定向类的错误，**301代表资源已经永久不存在了，需要更换URL来进行访问**，302代表资源还存在但是需要更换URL进行访问，400类代表客户端发送的请求报文有问题，例如403表示的是访问的资源没有权限，404表示访问的资源已经不存在了，500类代表服务器内部分错误，常见的例如502错误，代表服务器没有问题，但是访问后端服务器的请求出了问题

## **3.get和post请求的区别在哪里？**

get和post都是HTTP协议所定义的一种和服务器进行交互的规范，那根据定义，get是用来进行数据查询的，post是用来对数据进行修改操作的，因此get无法修改服务器额资源，得到的资源是一样的，可以对get的数据做缓存，其次get所带的请求参数是夹杂在URL中的，而post请求的参数是放在请求体的body中的，因此get请求的参数是直接可见的并且长度也会有限制，但是post请求的参数是不可见的，必须通过抓包来查看

## **4.HTTP的特性（HTTP1.1）？**

我拿HTTP1.1来谈一谈，分别有优点和缺点两方面

首先**优点**的话有三点

第一点就是简单易于理解，http都是消息头加上消息体的形式，其中消息头都是key-value的形式

第二点就是扩展性强，因为Http是属于应用层这一层的可以自己加很多东西，比如http1.1和http2.0都是基于tcp协议的，但是http3.0的时候底层协议就换成了udp协议，https协议就是在http协议的基础之上往下加了一个安全传输层

第三点就是跨平台通用性强，在手机平板电脑各种浏览器中都都可以用这种协议

其次**缺点**，有两点

第一点就是明文传输，不够安全，无论是get请求还是post请求，都可以查看到请求所携带的参数，如果这些信息涉及到敏感或者隐私信息，会造成安全隐患

第二点就是无状态，一些涉及到记忆操作的比如登录，购买，收藏的操作现在都需要借助cookie技术来实现，否则每次都要来进行验证信息

## **5.HTTP1.1的性能？**

http1.1性能方面有三大特性

第一点就是长连接，TCP协议相比于UDP协议，核心的就是能够确保稳定可靠的传输，因此进行TCP链接和断开链接的时候，都需要进行TCP的三次握手和四次挥手，HTTP1.0没有长连接的时候，这样每次的三次握手和四次挥手其实会造成相当的时间和性能开销，到了HTTP1.1的时候建立了所谓长连接的概念，有点类似于持久连接，只要双方没有非常明确的发出断开连接的请求，就会一直保持tcp链接，这样就避免了多次重复的tcp连接和断开连接的开销

第二点就是管道传输，因为有了长连接的特性，所以http1.1协议下，每一次发出请求不需要等待上一次请求返回结果，这样就避免了请求的阻塞，类似于上一个请求迟迟没有返回消息，后面的请求都没有办法进行发送，但是服务器还是要根据请求的顺序来返回请求，这样的话一个请求反不回去，那么服务器后门所有的服务器就都会被阻塞在服务器发送不出去，因此HTTP1.1解决了队头阻塞，但是没有解决响应的对头阻塞

## **6.HTTP与HTTPS的不同，HTTPS解决了HTTP的什么问题**

HTTP的最大特点就是明文传输，所传输的信息可以轻易的被截取造成信息的泄露，有时候甚至会访问到钓鱼网站，或者植入垃圾信息，HTTPS和HTTP最大的不同或者说改进就是在HTTP和TCP层之间加入了SSL/TLS层对内容进行了加密，解决HTTP存在的内容有可能被泄露、篡改冒充的风险。HTTPS主要采取了以下的技术确保了内容的加密和安全：

第一个就是混合加密技术，顾名思义他是混合了两种加密的算法，分别是对称加密和非对称加密，非对称加密的思想比较简单，HTTP不是明文传输吗，那就直接生成两个公钥，直接用公钥对内容进行加密和解密，服务器首先用公钥对内容进行加密，再把公钥和加密后的内容一并发送给浏览器，浏览器再将拿到的公钥对内容进行解密就可以了，但这种方式还是比较掩耳盗铃，虽然内容进行了加密，别人一眼看不出内容，但是别人可以轻易的截取公钥，可以用公钥对内容轻松解密，由此另一种加密方式非对称加密出现了吧，他和对称加密最大的不同就在于，服务器不会生成两个一样的公钥，而是会生成一个私钥和一个公钥，服务器会用私钥对内容进行加密，加密后的内容只能通过配对的公钥进行解密，反之亦然，服务器会用私钥来对内容进行加密，加密完成后，私钥留在服务器自己身边，把公钥和加密后的内容传递给浏览器，浏览器拿到公钥之后就可以对私钥加密的内容进行解密，然后浏览器可以用公钥对内容进行加密，直接把加密后的内容给服务器，在这个过程中服务器传递给浏览器的内容实际上还是会被泄露，可以将公钥进行拦截，直接对内容进行解密，但是反过来，浏览器通过公钥加密发送给服务器的内容无法被解密，因为拦截者拿不到私钥，这个时候其实只实现了单项的加密，因此HTTPS将这两个方法结合，使用了混合加密技术，其基本过程是这样的，首先过程中会采用非对称加密服务器端会生成一个公钥和一个私钥，服务器会保留私钥，直接把公钥发送给浏览器，浏览器直接拿到公钥后，自己此时会采用对称加密生成两个公钥，用服务器的公钥对浏览器的公钥进行加密，完成后浏览器把内容发送给服务器，在这个过程中有由于非对称加密的特性，即使中间人截取到了服务器的公钥也无法拿到服务器公钥加密过的浏览器公钥，因此完成此次传输后，服务器和浏览器都有了自己才知道的公钥（浏览器生成的），就可以安全高速的传输内容了。

但是光靠这个非对称加密仍然存在风险，例如中间人可以假冒服务器，伪造一个公钥给浏览器发送过去，浏览器接收到这个公钥之后以为是服务器的公钥就用这个接受的公钥对自己的公钥加密发送出去了，这样中间人可以接获到浏览器用自己的公钥加密的浏览器公钥，从而获取到浏览器的公钥，这样非对称加密就失效了，因此对服务器发过来的公钥进行核实就成为了一个问题，因此就引出了下面的两个技术，分别是数字签名和数字证书CA。

首先服务器会将自己的公钥和持有人信息等发送给CA，CA对公钥等内容进行一个摘要哈希计算，然后对这个哈希值使用CA的私钥进行加密生成一个数字签名，最后CA会将公钥、持有人信息和数字签名一起打包成一个数字证书返回给服务器。服务器拿到这个数字证书的时候，会直接使用使用非对称加密把这个证书传送给浏览器，浏览器拿到这个数字证书后，首先会使用内置的CA公钥对数字签名解密得到一个原本证书的摘要哈希值，然后再利用对应的hash方法传过来的证书内容自己再生成一个摘要哈希值，将两者进行比对，如果是一样的，，就证明传过来的公钥就是服务器的公钥而且没有被修改过，但是如果不一致，就代表传过来的证书内容被篡改过不可信。

## **7.谈谈HTTPS是如何建立连接的**

总的来说分三步，第一步浏览器获取到服务器的证书并进行验收，第二步就是双方建立起会话密钥，开始密钥会话，第三步就是进行密钥会话。前两步就是建立ssl/tls安全连接的过程，也就是通常所说的tls四次握手。

第一次握手：

浏览器会发送一个client hello请求，告诉服务器自己的可以使用的TLS版本，可以使用的加密算法例如RSA算法，还会发送一个数字，用来之后生成会话密钥

第二次握手：

服务器会发送一个sever hello请求，确认TLS协议，确认可以使用的加密算法例如RSA算法，然后会再次生成一个随机数传递给客户端，然后会通过给客户端传一个证书

第三次握手：

客户端接受到服务器的请求之后，会对服务端发给自己的数字证书进行核实，如果核实下来没有问题，会从中取出公钥，同时给服务端再次发送一个随机数字，这是四次握手中的第三个也是最后一个随机数字，并且告诉服务端，加密通信算法已经改变了，接下来都会采用密钥通信，然后会对之前的通话内容进行摘要，用来提供给服务端进行校验

第四次握手：

服务器这个时候也会通知客户端通信加密算法已经改变，接下来都会采用密钥进行通信，服务端也会对之前的会话生成摘要发给客户端进行验证

## **8.谈谈HTTPS如何确保数据的完整性**

SSL/TLS协在实现上主要分为两部分，一部分是握手协议，一部分是记录协议，四次握手就属于前面的握手协议，记录协议主要来负责数据的完整和真实性。

我当初在学这个的时候其实有一个疑惑，经历了ssl/tls的四次握手，其实服务端和客户端已经建立了密钥会话了，内容已经加密了，为什么还需要来验证信息的完整性呢，加密的信息还能被篡改吗，那个时我查阅了资料了解到了，其实即使加密了，对加密的信息进行截取和重放攻击其实不是完全不可能，只是难度增加了不少，比如收小明去转账，转账了100块钱，劫持者劫持了这个信息，虽然不知道这个加密信息的所以，但可以无脑进行重放攻击，这样转账的操作可能就会执行很多次。

因此就引出了消息认证码(MAC值)，基本流程是这样的，第一步，消息会被切片，第二步，切片会被压缩，第三步，给切片加上MAC值，这个值会通过片段的编号和内容来计算，计算完之后再加上其他信息交给tcp协议进行发送

## **9.HTTPS一定安全可靠吗？**

目前为止HTTPS协议本身可以说非常安全可靠，目前出现的问题我觉得大部分还是在HTTPS协议之外，比如服务器本身的漏洞，比如用户的密码设置的太弱被破解，比如用户在HTTPS协议识别出来证书有问题依然坚持访问等等，中间基站伪造这件事除非用户自己同意，否则就是不可能的，因为中间基站和客户端进行ssl/tls四次握手的时候中间基站提供的自己的公钥是可以被识别出来非法的，除非用户自己同意非法基站才有可能与与客户端经理四次ssl握手，紧接着与服务器进行四次握手，而中间基站就可以作为中间人截获到所有的信息

## **10.HTTP1.0 ----> HTTP1.1,有如何改进？**

相比于http1.0，http1.1最大的不同就是使用了长连接机制和管道技术，之前在http1.0每次建立连接的时候都得经历tcp的三次握手的过程，每次这样干，就会造成相当的性能和时间消耗，因此建立了长连接机制，只要第一次建立起连接，这个连接除非双方明确地提出要断开，否则就会一直保持，下次再次进行请求的时候直接发送请求就可以了。第二个就是管道机制，之前http1.0发送请求都是一个接一个，上一个的请求返回之后，才能发送下一个，造成请求阻塞的问题，http1.1改进了这一点，可以不必等待上一个请求发送完，就可以接着立马发送下一个请求

但是http1.1不可避免的还留有一些问题，第一个就比如说这个管道机制虽然解决了请求阻塞的问题，但是服务端那边的响应请求还是得一个一个请求的返回，因为他要遵循先进先出的请求，万一一个请求特别大或者其他问题就会造成响应的阻塞，并且http1.1的管道技术并不是默认就开且的，有的浏览器其实压根都不支持

第二个缺点就是http1.1仅仅对body进行了压缩，对头部没有进行相应的压缩，因此每次发送的时候都会带上大量的头部信息

第三个缺点就是请求不进行优先级的区分

第四个缺点就是只能从客户端开始，服务端只能进行被动访问

## **11.HTTP1.1---->HTTP2.0,有如何改进？**

http2.0相比http1.1比较大的改进有4点，

第一点就是头部压缩，服务端和客户端都会维护一张包含头部所有字段信息的表格，这样在发送http请求的时候只需要发送对应字段的索引值就可以了，并且对于大量的重复和相似的头部会进行压缩

第二点就是采用了二进制传输，http1.1中的所有报文的body和head都是纯文本的信息，而http2.0将报文的头部和消息体都采用了二进制进行传输，例如200这个状态，http1.1可能需要消耗三个字节，但是http2.0采用八位二进制只需要消耗一个字节，并且统称为帧，例如头信息帧和数据帧

第三点就是并发传输，http1.1和http1.0基本上都是采用了请求-响应的应答模式，但是http2.0出现了stream流这个概念，一个tcp协议中会有很多stream流，一个stream流中会有很多的message，这个message对应着http1.1中的请求或者响应，一个message中会存放有很多的请求头帧和请求体帧，这个都会放在一个message中，针对不同的http请求，会有一个独一无二的stream id，因此可以并发不同的stream，也就是http2可以并行交错的发送请求和响应，从根本上改变了http1.1和http1.0的请求响应模式，并且每一个streamid都会有一个权重值，这个权重值解决了请求没有优先级的问题

第四点就是服务端可以主动发起请求，比如说，客户端请求服务端的一个html文件，这个时候服务端会提前主动发送对应html的css文件，不用等客户端再来问

http2.0从http协议层面解决了http1.1遗留下来的“对头阻塞”问题，但是http2.0依旧是基于tcp协议的，tcp协议依旧是基于字节来进行传输的，tcp协议还是需要保证自己接受的数据是完整的才会把数据从缓存区域发送出去，一旦有一个数据丢了就要一直等待然后重传，因此还是存在一定的对头阻塞的文通

## **12.HTTP3.0讲一讲？相比于HTTP2.0做出了如何的改进？**

HTTP3.0相比于HTTP2.0，抛弃了TCP协议采用了UDP协议，HTTP3.0相比于HTTP2.0的提升也主要是依靠UDP带来的

UDP不像TCP，不会管发送的顺序，也不会管发送的丢包，所以也就不存在HTTP2.0的队头阻塞的问题，基于UDP协议的QUIC协议实现了类似TCP的稳定传输，基于此也给HTTP3.带来了以下的几个特点

1.第一个就是解决了对头阻塞的问题

2.第二个就是带来了更快的连接，相比于先进行TCP的三次握手，然后再进行SSL/SSL的四次握手，QUIC协议融合并缩短了握手的此说

3.第三个就是tcp是通过源地址、源端口、目标地址、目标端口来确定一次请求的，因此例如当手机wifi切换成流量的时候，ip就会发生改变，这个时候tcp就要断开重连，重新经历握手，就会造成可感知的明显卡顿，但是udp是通过两个设备的id来进行通信的，所以就不存在这些问题。

## **13.WebSocket是什么，和HTTP协议有什么不同**

首先根据这个OSI的七层网络模型，这个WebSocket和HTTP都是属于这个最顶层的应用层的协议，他们都基于TCP这个传输层的协议进行，我首先来讲一下TCP，这个其实是负责真正传输的协议，他有三个特点就是面向连接，安全可靠，面向字节流，但是这个只是进行了传输，但是传输的内容我需要的从哪里开始和结束，内容是什么，都没有一个区分和规定，会存在粘包的一个问题，不能直接去用，所以在其上层有了一个HTTP协议，会对消息进行区分，增加消息头，和消息列项之类的信息，标注信息的起始和类型，这样我们才可以真正的识别和去用这个信息，但是HTTP有一个特点就是，他是一个半双工的协议，什么是半双工呢，就是，同一个时间，只能由服务端和这个客户端一端来发送信息，TCP通过三次握手，其实双方是接受这个互相发送信息的，属于这个全双工，但是这个HTTP进行了阉割，因为和最初的设计有关系，本来就是考虑这个网页的更多静态展示用途，没考虑过这种游戏或者聊天的场景。而我这个项目的弹幕功能，HTTP其实就是满足不了的，因为一个用户发送了弹幕，需要发送给服务器后端，服务器后端也同时需要进行发送个前端，可以发现这个HTTP协议的半双工协议，是完全不可行的。所以才引入了这个WebSocket协议，这个协议同样基于TCP，三次握手之后，依然会调用HTTP协议，并发出一个协议升级的请求，在这个请求头里带上特殊的字段，后续会升级成这个WebSocket协议，这个协议，相比于HTTP，就是一个全双工的协议，支持，服务端和客户端可以互相发送信息，非常适合这种服务端和客户端交互频繁的场景。
