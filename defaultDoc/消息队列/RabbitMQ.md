# RabitMQ

## 1.RabitMQ如何保证消息不丢失

第一个就是开启生产者确认机制，确保消息能够到达队列

第二个就是进行消息的持久化，其中的交换机、队列和消息都需要进行持久化

第三个就是开始消费者的确认机制，并且设置确认机制为auto，如果消息处理消费成功就返回ack

第四个就是开启重试机制，如果失败过多就放入失败队列，由人工来进行处理

## 2.如何避免消息的重复消费

首先这个重复消费一般是由于网络波动导致的，例如，消费者消费完，还没来得及返回ACK，网络中断了，网络重新恢复的适合，消息还在队列里，又去消费了一次。解决办法一半有两种，一种设置唯一的Id，判断id是否已经存在，另一个就是用分布式锁这种幂等的解决方案。

## 3.Java中的延迟队列或者死信队列有了解过吗

延迟队列底层就是使用了死信队列+TTL来实现的，如果在队列中的消息超时没有被消费，就会传入死信队列中，等待死信队列来进行消费.

## 4.消息堆积的问题改如何解决

消息堆积的问题是由于消息队列中的消息太多来不及消费,到达存储上限,很多过来的消息变成死信。有多种方法可以解决这个问题。第一个办法就是增加消费者的消息消费能力，比如在消费者的内部用线程池来增加消费的速度。第二种就是增加消费者的数量，这个也是一种加快消费者消费速度的方式。第三种就是增加消息队列的队列容量，可以暂存更多消息的能力。这种一般会使用惰性队列，也就是说把消息存到磁盘上去，、正好磁盘的空间大，可以放很多的数据，虽然速度慢，有IO开销，但是需要的时候取就好了，频率也不会太高

## 5.RabbitMQ的高可用性机制你知道吗?

一般通过集群来保证RabbitMQ的高可用性,比如说镜像集群模式,设置有主从节点,主节点,每次都会去向这个镜像节点进行数据的备份,但这种模式也有一些问题,比如收这个主节点没有来得及进行数据的同步,这个时候突然这个从主节点就挂了,这个时候还可以采用仲裁者的集群模式.采用Raft协议来保证高可用性,使用集群的时候只要进行申明一下就好了.

## Kafaka
